-- Phase 1 foundation schema for quiz, matches, anonymous chat, and reveal toggle.

create extension if not exists pgcrypto;

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = timezone('utc', now());
  return new;
end;
$$;

create or replace function public.current_request_user_id()
returns text
language plpgsql
stable
as $$
declare
  v_claim_user_id text;
  v_claims_raw text;
begin
  v_claim_user_id := nullif(current_setting('request.jwt.claim.user_id', true), '');
  if v_claim_user_id is not null then
    return v_claim_user_id;
  end if;

  v_claims_raw := nullif(current_setting('request.jwt.claims', true), '');
  if v_claims_raw is not null then
    begin
      v_claim_user_id := nullif((v_claims_raw::jsonb ->> 'user_id'), '');
    exception
      when others then
        v_claim_user_id := null;
    end;

    if v_claim_user_id is not null then
      return v_claim_user_id;
    end if;
  end if;

  v_claim_user_id := nullif(current_setting('request.header.x-user-id', true), '');
  if v_claim_user_id is not null then
    return v_claim_user_id;
  end if;

  v_claims_raw := nullif(current_setting('request.headers', true), '');
  if v_claims_raw is not null then
    begin
      v_claim_user_id := nullif(
        coalesce(
          v_claims_raw::jsonb ->> 'x-user-id',
          v_claims_raw::jsonb -> 'x-user-id' ->> 0
        ),
        ''
      );
    exception
      when others then
        v_claim_user_id := null;
    end;

    if v_claim_user_id is not null then
      return v_claim_user_id;
    end if;
  end if;

  v_claim_user_id := nullif(current_setting('app.current_user_id', true), '');
  return v_claim_user_id;
end;
$$;

create or replace function public.current_request_user_id_required()
returns text
language plpgsql
stable
as $$
declare
  v_user_id text;
begin
  v_user_id := public.current_request_user_id();
  if v_user_id is null then
    raise exception 'missing user_id claim/session context'
      using errcode = '22023';
  end if;
  return v_user_id;
end;
$$;

create table if not exists public.quiz_responses (
  id bigint generated by default as identity primary key,
  user_id text not null unique,
  user_name text,
  phone text,
  instagram_handle text,
  gender text,
  looking_for text,
  romantic integer not null default 0 check (romantic >= 0 and romantic <= 14),
  adventurous integer not null default 0 check (adventurous >= 0 and adventurous <= 14),
  intellectual integer not null default 0 check (intellectual >= 0 and intellectual <= 14),
  creative integer not null default 0 check (creative >= 0 and creative <= 14),
  chill integer not null default 0 check (chill >= 0 and chill <= 14),
  social integer not null default 0 check (social >= 0 and social <= 14),
  ambitious integer not null default 0 check (ambitious >= 0 and ambitious <= 14),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint quiz_responses_gender_check check (gender is null or gender in ('m', 'f')),
  constraint quiz_responses_looking_for_check check (looking_for is null or looking_for in ('m', 'f', 'mf'))
);

create table if not exists public.match_edges (
  id bigint generated by default as identity primary key,
  user_a_id text not null,
  user_b_id text not null,
  compatibility_a_to_b integer not null default 0 check (compatibility_a_to_b >= 0 and compatibility_a_to_b <= 100),
  compatibility_b_to_a integer not null default 0 check (compatibility_b_to_a >= 0 and compatibility_b_to_a <= 100),
  is_mutual_top3 boolean not null default false,
  refreshed_at timestamptz not null default timezone('utc', now()),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint match_edges_ordered_pair_check check (user_a_id < user_b_id),
  constraint match_edges_unique_pair unique (user_a_id, user_b_id),
  constraint match_edges_user_a_fk foreign key (user_a_id) references public.quiz_responses(user_id) on delete cascade,
  constraint match_edges_user_b_fk foreign key (user_b_id) references public.quiz_responses(user_id) on delete cascade
);

create table if not exists public.chat_threads (
  id uuid primary key default gen_random_uuid(),
  user_a_id text not null,
  user_b_id text not null,
  created_at timestamptz not null default timezone('utc', now()),
  revealed_at timestamptz,
  constraint chat_threads_distinct_users_check check (user_a_id <> user_b_id),
  constraint chat_threads_ordered_pair_check check (user_a_id < user_b_id),
  constraint chat_threads_unique_pair unique (user_a_id, user_b_id),
  constraint chat_threads_user_a_fk foreign key (user_a_id) references public.quiz_responses(user_id) on delete cascade,
  constraint chat_threads_user_b_fk foreign key (user_b_id) references public.quiz_responses(user_id) on delete cascade
);

create table if not exists public.chat_messages (
  id bigint generated by default as identity primary key,
  thread_id uuid not null,
  sender_user_id text not null,
  body text not null,
  created_at timestamptz not null default timezone('utc', now()),
  constraint chat_messages_body_not_blank check (length(btrim(body)) > 0),
  constraint chat_messages_thread_fk foreign key (thread_id) references public.chat_threads(id) on delete cascade,
  constraint chat_messages_sender_fk foreign key (sender_user_id) references public.quiz_responses(user_id) on delete cascade
);

create table if not exists public.chat_aliases (
  thread_id uuid not null,
  user_id text not null,
  alias text not null,
  created_at timestamptz not null default timezone('utc', now()),
  constraint chat_aliases_alias_not_blank check (length(btrim(alias)) > 0),
  constraint chat_aliases_pk primary key (thread_id, user_id),
  constraint chat_aliases_unique_alias_per_thread unique (thread_id, alias),
  constraint chat_aliases_thread_fk foreign key (thread_id) references public.chat_threads(id) on delete cascade,
  constraint chat_aliases_user_fk foreign key (user_id) references public.quiz_responses(user_id) on delete cascade
);

create table if not exists public.app_settings (
  id smallint primary key default 1,
  reveal_enabled boolean not null default false,
  revealed_at timestamptz,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint app_settings_singleton_check check (id = 1)
);

create index if not exists quiz_responses_gender_idx
  on public.quiz_responses (gender);

create index if not exists quiz_responses_looking_for_idx
  on public.quiz_responses (looking_for);

create index if not exists match_edges_user_a_idx
  on public.match_edges (user_a_id);

create index if not exists match_edges_user_b_idx
  on public.match_edges (user_b_id);

create index if not exists match_edges_is_mutual_top3_idx
  on public.match_edges (is_mutual_top3)
  where is_mutual_top3 = true;

create index if not exists chat_threads_user_a_idx
  on public.chat_threads (user_a_id);

create index if not exists chat_threads_user_b_idx
  on public.chat_threads (user_b_id);

create index if not exists chat_messages_thread_created_idx
  on public.chat_messages (thread_id, created_at desc);

create index if not exists chat_messages_sender_idx
  on public.chat_messages (sender_user_id);

create index if not exists chat_aliases_user_idx
  on public.chat_aliases (user_id);

insert into public.app_settings (id, reveal_enabled, revealed_at)
values (1, false, null)
on conflict (id) do nothing;

create or replace function public.is_thread_participant(p_thread_id uuid, p_user_id text default public.current_request_user_id())
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.chat_threads t
    where t.id = p_thread_id
      and p_user_id is not null
      and p_user_id in (t.user_a_id, t.user_b_id)
  );
$$;

create or replace function public.submit_quiz_and_refresh_matches(payload jsonb)
returns jsonb
language plpgsql
security invoker
set search_path = public, pg_temp
as $$
declare
  v_user_id text;
  v_row public.quiz_responses;
begin
  v_user_id := public.current_request_user_id_required();

  insert into public.quiz_responses (
    user_id,
    user_name,
    phone,
    instagram_handle,
    gender,
    looking_for,
    romantic,
    adventurous,
    intellectual,
    creative,
    chill,
    social,
    ambitious
  )
  values (
    v_user_id,
    nullif(payload ->> 'user_name', ''),
    nullif(payload ->> 'phone', ''),
    nullif(payload ->> 'instagram_handle', ''),
    nullif(payload ->> 'gender', ''),
    nullif(payload ->> 'looking_for', ''),
    coalesce((payload ->> 'romantic')::integer, 0),
    coalesce((payload ->> 'adventurous')::integer, 0),
    coalesce((payload ->> 'intellectual')::integer, 0),
    coalesce((payload ->> 'creative')::integer, 0),
    coalesce((payload ->> 'chill')::integer, 0),
    coalesce((payload ->> 'social')::integer, 0),
    coalesce((payload ->> 'ambitious')::integer, 0)
  )
  on conflict (user_id)
  do update set
    user_name = coalesce(excluded.user_name, public.quiz_responses.user_name),
    phone = coalesce(excluded.phone, public.quiz_responses.phone),
    instagram_handle = coalesce(excluded.instagram_handle, public.quiz_responses.instagram_handle),
    gender = coalesce(excluded.gender, public.quiz_responses.gender),
    looking_for = coalesce(excluded.looking_for, public.quiz_responses.looking_for),
    romantic = excluded.romantic,
    adventurous = excluded.adventurous,
    intellectual = excluded.intellectual,
    creative = excluded.creative,
    chill = excluded.chill,
    social = excluded.social,
    ambitious = excluded.ambitious,
    updated_at = timezone('utc', now())
  returning * into v_row;

  -- Placeholder: detailed edge recomputation is implemented in a later migration.
  return jsonb_build_object(
    'ok', true,
    'user_id', v_row.user_id,
    'quiz_response_id', v_row.id,
    'matches_refreshed', false,
    'matches', jsonb_build_array()
  );
end;
$$;

create or replace function public.create_thread_if_mutual(match_user_id text)
returns public.chat_threads
language plpgsql
security definer
set search_path = public, pg_temp
as $$
declare
  v_me text;
  v_user_a text;
  v_user_b text;
  v_thread public.chat_threads;
begin
  v_me := public.current_request_user_id_required();

  if match_user_id is null or btrim(match_user_id) = '' then
    raise exception 'match_user_id is required' using errcode = '22023';
  end if;

  if v_me = match_user_id then
    raise exception 'cannot create thread with self' using errcode = '22023';
  end if;

  v_user_a := least(v_me, match_user_id);
  v_user_b := greatest(v_me, match_user_id);

  select *
  into v_thread
  from public.chat_threads
  where user_a_id = v_user_a
    and user_b_id = v_user_b;

  if found then
    return v_thread;
  end if;

  if not exists (
    select 1
    from public.match_edges me
    where me.user_a_id = v_user_a
      and me.user_b_id = v_user_b
      and me.is_mutual_top3 = true
  ) then
    raise exception 'pair is not currently mutual top-3 eligible for chat' using errcode = '42501';
  end if;

  insert into public.chat_threads (user_a_id, user_b_id)
  values (v_user_a, v_user_b)
  on conflict (user_a_id, user_b_id)
  do update set
    user_a_id = excluded.user_a_id
  returning * into v_thread;

  insert into public.chat_aliases (thread_id, user_id, alias)
  values
    (v_thread.id, v_user_a, 'Anon-' || substr(md5(v_thread.id::text || ':' || v_user_a), 1, 8)),
    (v_thread.id, v_user_b, 'Anon-' || substr(md5(v_thread.id::text || ':' || v_user_b), 1, 8))
  on conflict (thread_id, user_id) do nothing;

  return v_thread;
end;
$$;

create or replace function public.list_my_threads()
returns table (
  thread_id uuid,
  user_a_id text,
  user_b_id text,
  other_user_id text,
  created_at timestamptz,
  revealed_at timestamptz,
  my_alias text,
  other_alias text,
  last_message_at timestamptz,
  last_message_preview text
)
language sql
security invoker
stable
set search_path = public, pg_temp
as $$
  with me as (
    select public.current_request_user_id() as user_id
  )
  select
    t.id as thread_id,
    t.user_a_id,
    t.user_b_id,
    case
      when t.user_a_id = me.user_id then t.user_b_id
      else t.user_a_id
    end as other_user_id,
    t.created_at,
    t.revealed_at,
    my_alias.alias as my_alias,
    other_alias.alias as other_alias,
    last_message.created_at as last_message_at,
    last_message.preview as last_message_preview
  from public.chat_threads t
  cross join me
  left join public.chat_aliases my_alias
    on my_alias.thread_id = t.id
   and my_alias.user_id = me.user_id
  left join public.chat_aliases other_alias
    on other_alias.thread_id = t.id
   and other_alias.user_id = case when t.user_a_id = me.user_id then t.user_b_id else t.user_a_id end
  left join lateral (
    select
      m.created_at,
      left(m.body, 160) as preview
    from public.chat_messages m
    where m.thread_id = t.id
    order by m.created_at desc
    limit 1
  ) last_message on true
  where me.user_id is not null
    and me.user_id in (t.user_a_id, t.user_b_id)
  order by coalesce(last_message.created_at, t.created_at) desc;
$$;

drop trigger if exists trg_quiz_responses_set_updated_at on public.quiz_responses;
create trigger trg_quiz_responses_set_updated_at
before update on public.quiz_responses
for each row
execute function public.set_updated_at();

drop trigger if exists trg_match_edges_set_updated_at on public.match_edges;
create trigger trg_match_edges_set_updated_at
before update on public.match_edges
for each row
execute function public.set_updated_at();

drop trigger if exists trg_app_settings_set_updated_at on public.app_settings;
create trigger trg_app_settings_set_updated_at
before update on public.app_settings
for each row
execute function public.set_updated_at();

alter table public.quiz_responses enable row level security;
alter table public.match_edges enable row level security;
alter table public.chat_threads enable row level security;
alter table public.chat_messages enable row level security;
alter table public.chat_aliases enable row level security;
alter table public.app_settings enable row level security;

drop policy if exists quiz_responses_select_own on public.quiz_responses;
create policy quiz_responses_select_own
  on public.quiz_responses
  for select
  using (user_id = public.current_request_user_id());

drop policy if exists quiz_responses_insert_own on public.quiz_responses;
create policy quiz_responses_insert_own
  on public.quiz_responses
  for insert
  with check (user_id = public.current_request_user_id());

drop policy if exists quiz_responses_update_own on public.quiz_responses;
create policy quiz_responses_update_own
  on public.quiz_responses
  for update
  using (user_id = public.current_request_user_id())
  with check (user_id = public.current_request_user_id());

drop policy if exists quiz_responses_delete_own on public.quiz_responses;
create policy quiz_responses_delete_own
  on public.quiz_responses
  for delete
  using (user_id = public.current_request_user_id());

drop policy if exists match_edges_select_participant on public.match_edges;
create policy match_edges_select_participant
  on public.match_edges
  for select
  using (public.current_request_user_id() in (user_a_id, user_b_id));

drop policy if exists chat_threads_select_participant on public.chat_threads;
create policy chat_threads_select_participant
  on public.chat_threads
  for select
  using (public.current_request_user_id() in (user_a_id, user_b_id));

drop policy if exists chat_messages_select_participant on public.chat_messages;
create policy chat_messages_select_participant
  on public.chat_messages
  for select
  using (public.is_thread_participant(thread_id));

drop policy if exists chat_messages_insert_sender on public.chat_messages;
create policy chat_messages_insert_sender
  on public.chat_messages
  for insert
  with check (
    sender_user_id = public.current_request_user_id()
    and public.is_thread_participant(thread_id)
  );

drop policy if exists chat_aliases_select_participant on public.chat_aliases;
create policy chat_aliases_select_participant
  on public.chat_aliases
  for select
  using (public.is_thread_participant(thread_id));

drop policy if exists app_settings_select_all on public.app_settings;
create policy app_settings_select_all
  on public.app_settings
  for select
  using (true);

grant usage on schema public to anon, authenticated;

grant select, insert, update, delete on public.quiz_responses to anon, authenticated;
grant select on public.match_edges to anon, authenticated;
grant select on public.chat_threads to anon, authenticated;
grant select, insert on public.chat_messages to anon, authenticated;
grant select on public.chat_aliases to anon, authenticated;
grant select on public.app_settings to anon, authenticated;

grant usage, select on sequence public.quiz_responses_id_seq to anon, authenticated;
grant usage, select on sequence public.match_edges_id_seq to anon, authenticated;
grant usage, select on sequence public.chat_messages_id_seq to anon, authenticated;

grant execute on function public.current_request_user_id() to anon, authenticated;
grant execute on function public.current_request_user_id_required() to anon, authenticated;
grant execute on function public.is_thread_participant(uuid, text) to anon, authenticated;
grant execute on function public.submit_quiz_and_refresh_matches(jsonb) to anon, authenticated;
grant execute on function public.create_thread_if_mutual(text) to anon, authenticated;
grant execute on function public.list_my_threads() to anon, authenticated;
