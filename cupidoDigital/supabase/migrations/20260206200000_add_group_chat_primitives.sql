-- Add single-primary-group primitives, group chat tables, onboarding metadata, and RLS.

create table if not exists public.course_options (
  code text primary key,
  label text not null,
  sort_order smallint not null unique check (sort_order > 0),
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint course_options_code_not_blank check (length(btrim(code)) > 0),
  constraint course_options_label_not_blank check (length(btrim(label)) > 0)
);

create table if not exists public.quiz_groups (
  id uuid primary key default gen_random_uuid(),
  group_key text not null unique,
  label text not null,
  sort_order smallint not null unique check (sort_order > 0),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint quiz_groups_group_key_not_blank check (length(btrim(group_key)) > 0),
  constraint quiz_groups_label_not_blank check (length(btrim(label)) > 0)
);

create table if not exists public.user_group_memberships (
  user_id text primary key,
  group_id uuid not null,
  is_primary boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint user_group_memberships_primary_check check (is_primary = true),
  constraint user_group_memberships_user_fk foreign key (user_id) references public.quiz_responses(user_id) on delete cascade,
  constraint user_group_memberships_group_fk foreign key (group_id) references public.quiz_groups(id) on delete restrict
);

create table if not exists public.group_threads (
  id uuid primary key default gen_random_uuid(),
  group_id uuid not null unique,
  created_at timestamptz not null default timezone('utc', now()),
  constraint group_threads_group_fk foreign key (group_id) references public.quiz_groups(id) on delete cascade
);

create table if not exists public.group_messages (
  id bigint generated by default as identity primary key,
  thread_id uuid not null,
  sender_user_id text not null,
  body text not null,
  created_at timestamptz not null default timezone('utc', now()),
  constraint group_messages_body_not_blank check (length(btrim(body)) > 0),
  constraint group_messages_thread_fk foreign key (thread_id) references public.group_threads(id) on delete cascade,
  constraint group_messages_sender_fk foreign key (sender_user_id) references public.quiz_responses(user_id) on delete cascade
);

create table if not exists public.group_aliases (
  thread_id uuid not null,
  user_id text not null,
  alias text not null,
  created_at timestamptz not null default timezone('utc', now()),
  constraint group_aliases_alias_not_blank check (length(btrim(alias)) > 0),
  constraint group_aliases_pk primary key (thread_id, user_id),
  constraint group_aliases_unique_alias_per_thread unique (thread_id, alias),
  constraint group_aliases_thread_fk foreign key (thread_id) references public.group_threads(id) on delete cascade,
  constraint group_aliases_user_fk foreign key (user_id) references public.quiz_responses(user_id) on delete cascade
);

alter table public.quiz_responses
  add column if not exists course_code text,
  add column if not exists study_year text,
  add column if not exists profile_locked_at timestamptz;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'quiz_responses_course_code_fk'
      and conrelid = 'public.quiz_responses'::regclass
  ) then
    alter table public.quiz_responses
      add constraint quiz_responses_course_code_fk
      foreign key (course_code) references public.course_options(code)
      on update cascade
      on delete set null;
  end if;
end;
$$;

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'quiz_responses_study_year_check'
      and conrelid = 'public.quiz_responses'::regclass
  ) then
    alter table public.quiz_responses
      add constraint quiz_responses_study_year_check
      check (study_year is null or study_year in ('year_1', 'year_2', 'year_3'));
  end if;
end;
$$;

create index if not exists quiz_responses_course_code_idx
  on public.quiz_responses (course_code);

create index if not exists user_group_memberships_group_idx
  on public.user_group_memberships (group_id);

create index if not exists group_messages_thread_created_idx
  on public.group_messages (thread_id, created_at desc, id desc);

create index if not exists group_messages_sender_idx
  on public.group_messages (sender_user_id);

create index if not exists group_aliases_user_idx
  on public.group_aliases (user_id);

drop trigger if exists trg_course_options_set_updated_at on public.course_options;
create trigger trg_course_options_set_updated_at
before update on public.course_options
for each row
execute function public.set_updated_at();

drop trigger if exists trg_quiz_groups_set_updated_at on public.quiz_groups;
create trigger trg_quiz_groups_set_updated_at
before update on public.quiz_groups
for each row
execute function public.set_updated_at();

drop trigger if exists trg_user_group_memberships_set_updated_at on public.user_group_memberships;
create trigger trg_user_group_memberships_set_updated_at
before update on public.user_group_memberships
for each row
execute function public.set_updated_at();

insert into public.course_options (code, label, sort_order, is_active)
values
  ('cs', 'Computer Science', 1, true),
  ('ee', 'Electrical Engineering', 2, true),
  ('me', 'Mechanical Engineering', 3, true),
  ('ce', 'Civil Engineering', 4, true),
  ('bio', 'Biology', 5, true),
  ('chem', 'Chemistry', 6, true),
  ('math', 'Mathematics', 7, true),
  ('physics', 'Physics', 8, true),
  ('economics', 'Economics', 9, true),
  ('business', 'Business', 10, true),
  ('law', 'Law', 11, true),
  ('psychology', 'Psychology', 12, true)
on conflict (code)
do update set
  label = excluded.label,
  sort_order = excluded.sort_order,
  is_active = excluded.is_active,
  updated_at = timezone('utc', now());

insert into public.quiz_groups (group_key, label, sort_order)
values
  ('romantic', 'Romantic', 1),
  ('adventurous', 'Adventurous', 2),
  ('intellectual', 'Intellectual', 3),
  ('creative', 'Creative', 4),
  ('chill', 'Chill', 5),
  ('social', 'Social', 6),
  ('ambitious', 'Ambitious', 7)
on conflict (group_key)
do update set
  label = excluded.label,
  sort_order = excluded.sort_order,
  updated_at = timezone('utc', now());

insert into public.group_threads (group_id)
select qg.id
from public.quiz_groups qg
on conflict (group_id) do nothing;

create or replace function public.is_group_member(
  p_group_id uuid,
  p_user_id text default public.current_request_user_id()
)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.user_group_memberships ugm
    where ugm.group_id = p_group_id
      and p_user_id is not null
      and ugm.user_id = p_user_id
  );
$$;

create or replace function public.is_group_thread_member(
  p_thread_id uuid,
  p_user_id text default public.current_request_user_id()
)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.group_threads gt
    join public.user_group_memberships ugm
      on ugm.group_id = gt.group_id
    where gt.id = p_thread_id
      and p_user_id is not null
      and ugm.user_id = p_user_id
  );
$$;

create or replace function public.deterministic_group_alias(
  p_thread_id uuid,
  p_user_id text
)
returns text
language sql
immutable
as $$
  select 'Anon-' || substr(md5(coalesce(p_thread_id::text, '') || ':' || coalesce(p_user_id, '')), 1, 8);
$$;

alter table public.course_options enable row level security;
alter table public.quiz_groups enable row level security;
alter table public.user_group_memberships enable row level security;
alter table public.group_threads enable row level security;
alter table public.group_messages enable row level security;
alter table public.group_aliases enable row level security;

drop policy if exists course_options_select_all on public.course_options;
create policy course_options_select_all
  on public.course_options
  for select
  using (true);

drop policy if exists quiz_groups_select_all on public.quiz_groups;
create policy quiz_groups_select_all
  on public.quiz_groups
  for select
  using (true);

drop policy if exists user_group_memberships_select_own on public.user_group_memberships;
create policy user_group_memberships_select_own
  on public.user_group_memberships
  for select
  using (user_id = public.current_request_user_id());

drop policy if exists user_group_memberships_insert_own on public.user_group_memberships;
create policy user_group_memberships_insert_own
  on public.user_group_memberships
  for insert
  with check (user_id = public.current_request_user_id());

drop policy if exists user_group_memberships_update_own on public.user_group_memberships;
create policy user_group_memberships_update_own
  on public.user_group_memberships
  for update
  using (user_id = public.current_request_user_id())
  with check (user_id = public.current_request_user_id());

drop policy if exists user_group_memberships_delete_own on public.user_group_memberships;
create policy user_group_memberships_delete_own
  on public.user_group_memberships
  for delete
  using (user_id = public.current_request_user_id());

drop policy if exists group_threads_select_member on public.group_threads;
create policy group_threads_select_member
  on public.group_threads
  for select
  using (public.is_group_member(group_id));

drop policy if exists group_messages_select_member on public.group_messages;
create policy group_messages_select_member
  on public.group_messages
  for select
  using (public.is_group_thread_member(thread_id));

drop policy if exists group_messages_insert_member_sender on public.group_messages;
create policy group_messages_insert_member_sender
  on public.group_messages
  for insert
  with check (
    sender_user_id = public.current_request_user_id()
    and public.is_group_thread_member(thread_id)
  );

drop policy if exists group_aliases_select_member on public.group_aliases;
create policy group_aliases_select_member
  on public.group_aliases
  for select
  using (public.is_group_thread_member(thread_id));

drop policy if exists group_aliases_insert_own_member on public.group_aliases;
create policy group_aliases_insert_own_member
  on public.group_aliases
  for insert
  with check (
    user_id = public.current_request_user_id()
    and public.is_group_thread_member(thread_id)
  );

drop policy if exists group_aliases_update_own_member on public.group_aliases;
create policy group_aliases_update_own_member
  on public.group_aliases
  for update
  using (
    user_id = public.current_request_user_id()
    and public.is_group_thread_member(thread_id)
  )
  with check (
    user_id = public.current_request_user_id()
    and public.is_group_thread_member(thread_id)
  );

drop policy if exists group_aliases_delete_own_member on public.group_aliases;
create policy group_aliases_delete_own_member
  on public.group_aliases
  for delete
  using (
    user_id = public.current_request_user_id()
    and public.is_group_thread_member(thread_id)
  );

grant select on public.course_options to anon, authenticated;
grant select on public.quiz_groups to anon, authenticated;
grant select, insert, update, delete on public.user_group_memberships to anon, authenticated;
grant select on public.group_threads to anon, authenticated;
grant select, insert on public.group_messages to anon, authenticated;
grant select, insert, update, delete on public.group_aliases to anon, authenticated;

grant usage, select on sequence public.group_messages_id_seq to anon, authenticated;

grant execute on function public.is_group_member(uuid, text) to anon, authenticated;
grant execute on function public.is_group_thread_member(uuid, text) to anon, authenticated;
grant execute on function public.deterministic_group_alias(uuid, text) to anon, authenticated;
